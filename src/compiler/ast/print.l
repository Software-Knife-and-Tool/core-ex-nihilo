(defun compiler:print (form level)
  (let* ((spaces
          (:lambda (l)
            (cond
             ((eq l 0) "")
             ((eq l 1) " ")
             ((eq l 2) "  ")
             ((eq l 3) "   ")
             ((eq l 4) "    ")
             ((eq l 5) "     ")
             ((eq l 6) "      ")
             ((eq l 7) "       ")
             ((eq l 8) "        ")
             ((eq l 9) "         ")
             (:t ""))))
         (special
          (:lambda (fn form)
            (cond
             ((eq fn :defcon)
              (fmt :t "special:defcon: (~A ~A)~%" (car form) (cdr form))
              (compiler:print (car form) (1+ level))
              (mapc (:lambda (form) (compiler:print form (1+ level))) (cdr form)))
             ((eq fn :quote)
              (fmt :t "special:quote: (~A . ~A)~%" form)
              (compiler:print (car form) (1+ level)))
             ((eq fn :lambda) (fmt :t "special:lambda: ~A ~A~%" (car form) (cdr form)))
             ((eq fn :letq) (fmt :t "special:letq: ~A ~A~%" (car form) (cdr form)))
             ((eq fn :macro) (fmt :t "special:macro: ~A ~A~%" (car form) (cdr form))))))
         (atomf
          (:lambda (expr)
            (cond
             ((null expr) (fmt :t "atom:nil~%") expr)
             ((eq expr :t) (fmt :t "atom:t~%") expr)
             ((keywordp expr)
              (fmt :t "atom:keyword ~A~%" expr)
              (when (special-operatorp expr) (fmt :t "special-operator: ~A~%")))
             ((symbolp expr) (fmt :t "atom:symbol ~A~%" expr))
             ((fixnump expr) (fmt :t "atom:fixnum ~A~%" expr))
             ((floatp expr) (fmt :t "atom:float ~A~%" expr))
             ((stringp expr) (fmt :t "atom:string ~A~%" expr))
             ((vectorp expr) (fmt :t "atom:vector ~A~%" expr))
             ((functionp expr) (fmt :t "atom:function ~A~%" expr)))))
         (funcall
           (:lambda (form)
            (let ((fn (car form))
                  (args (cdr form)))
              (cond
               ((and (symbolp fn) (special-operatorp fn))
                (fmt :t "funcall:special-operator: (~A . ~A)~%" fn args)
                (special fn form))
               ((macro-function fn) (fmt :t "funcall:macro: (~A . ~A)~%" fn args)
                (compiler:print fn (1+ level))
                (mapc (:lambda (form) (compiler:print form (1+ level))) args))
               ((symbolp fn)
                (fmt :t "funcall:symbol: (~A . ~A)~%" fn args)
                (compiler:print fn (1+ level))
                (mapc (:lambda (form) (compiler:print form (1+ level))) args))
               ((consp fn) (fmt :t "funcall:cons: (~A . ~A)~%" fn args)
                (compiler:print fn (1+ level))
                (mapc (:lambda (form) (compiler:print form (1+ level))) (cdr form)))
               ((functionp fn) (fmt :t "funcall:function: (~A . ~A)~%" fn args)
                (compiler:print fn (1+ level))
                (mapc (:lambda (form) (compiler:print form (1+ level))) args)))))))

    (cond
      ((or (null form) (atom form)) (atomf form))
      (:t (funcall form)))))

